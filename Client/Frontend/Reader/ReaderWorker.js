window.__firefox_readability_worker__ = "/*eslint-env es6:false*/\n/*\n * Copyright (c) 2010 Arc90 Inc\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * This code is heavily based on Arc90's readability.js (1.7.1) script\n * available at: http://code.google.com/p/arc90labs-readability\n */\n\n/**\n * Public constructor.\n * @param {Object}       uri     The URI descriptor object.\n * @param {HTMLDocument} doc     The document to parse.\n * @param {Object}       options The options object.\n */\nfunction Readability(uri, doc, options) {\n  options = options || {};\n\n  this._uri = uri;\n  this._doc = doc;\n  this._biggestFrame = false;\n  this._articleByline = null;\n  this._articleDir = null;\n\n  // Configureable options\n  this._debug = !!options.debug;\n  this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;\n  this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;\n  this._maxPages = options.maxPages || this.DEFAULT_MAX_PAGES;\n\n  // Start with all flags set\n  this._flags = this.FLAG_STRIP_UNLIKELYS |\n                this.FLAG_WEIGHT_CLASSES |\n                this.FLAG_CLEAN_CONDITIONALLY;\n\n  // The list of pages we've parsed in this call of readability,\n  // for autopaging. As a key store for easier searching.\n  this._parsedPages = {};\n\n  // A list of the ETag headers of pages we've parsed, in case they happen to match,\n  // we'll know it's a duplicate.\n  this._pageETags = {};\n\n  // Make an AJAX request for each page and append it to the document.\n  this._curPageNum = 1;\n\n  var logEl;\n\n  // Control whether log messages are sent to the console\n  if (this._debug) {\n    logEl = function(e) {\n      var rv = e.nodeName + \" \";\n      if (e.nodeType == e.TEXT_NODE) {\n        return rv + '(\"' + e.textContent + '\")';\n      }\n      var classDesc = e.className && (\".\" + e.className.replace(/ /g, \".\"));\n      var elDesc = \"\";\n      if (e.id)\n        elDesc = \"(#\" + e.id + classDesc + \")\";\n      else if (classDesc)\n        elDesc = \"(\" + classDesc + \")\";\n      return rv + elDesc;\n    };\n    this.log = function () {\n      if (typeof dump !== undefined) {\n        var msg = Array.prototype.map.call(arguments, function(x) {\n          return (x && x.nodeName) ? logEl(x) : x;\n        }).join(\" \");\n        dump(\"Reader: (Readability) \" + msg + \"\\n\");\n      } else if (typeof console !== undefined) {\n        var args = [\"Reader: (Readability) \"].concat(arguments);\n        console.log.apply(console, args);\n      }\n    };\n  } else {\n    this.log = function () {};\n  }\n}\n\nReadability.prototype = {\n  FLAG_STRIP_UNLIKELYS: 0x1,\n  FLAG_WEIGHT_CLASSES: 0x2,\n  FLAG_CLEAN_CONDITIONALLY: 0x4,\n\n  // Max number of nodes supported by this parser. Default: 0 (no limit)\n  DEFAULT_MAX_ELEMS_TO_PARSE: 0,\n\n  // The number of top candidates to consider when analysing how\n  // tight the competition is among candidates.\n  DEFAULT_N_TOP_CANDIDATES: 5,\n\n  // The maximum number of pages to loop through before we call\n  // it quits and just show a link.\n  DEFAULT_MAX_PAGES: 5,\n\n  // Element tags to score by default.\n  DEFAULT_TAGS_TO_SCORE: \"section,h2,h3,h4,h5,h6,p,td,pre\".toUpperCase().split(\",\"),\n\n  // All of the regular expressions in use within readability.\n  // Defined up here so we don't instantiate them repeatedly in loops.\n  REGEXPS: {\n    unlikelyCandidates: /banner|combx|comment|community|disqus|extra|foot|header|menu|modal|related|remark|rss|share|shoutbox|sidebar|skyscraper|sponsor|ad-break|agegate|pagination|pager|popup/i,\n    okMaybeItsACandidate: /and|article|body|column|main|shadow/i,\n    positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,\n    negative: /hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|masthead|media|meta|modal|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,\n    extraneous: /print|archive|comment|discuss|e[\\-]?mail|share|reply|all|login|sign|single|utility/i,\n    byline: /byline|author|dateline|writtenby|p-author/i,\n    replaceFonts: /<(\\/?)font[^>]*>/gi,\n    normalize: /\\s{2,}/g,\n    videos: /\\/\\/(www\\.)?(dailymotion|youtube|youtube-nocookie|player\\.vimeo)\\.com/i,\n    nextLink: /(next|weiter|continue|>([^\\|]|$)|»([^\\|]|$))/i,\n    prevLink: /(prev|earl|old|new|<|«)/i,\n    whitespace: /^\\s*$/,\n    hasContent: /\\S$/,\n  },\n\n  DIV_TO_P_ELEMS: [ \"A\", \"BLOCKQUOTE\", \"DL\", \"DIV\", \"IMG\", \"OL\", \"P\", \"PRE\", \"TABLE\", \"UL\", \"SELECT\" ],\n\n  ALTER_TO_DIV_EXCEPTIONS: [\"DIV\", \"ARTICLE\", \"SECTION\", \"P\"],\n\n  /**\n   * Run any post-process modifications to article content as necessary.\n   *\n   * @param Element\n   * @return void\n  **/\n  _postProcessContent: function(articleContent) {\n    // Readability cannot open relative uris so we convert them to absolute uris.\n    this._fixRelativeUris(articleContent);\n  },\n\n  /**\n   * Iterates over a NodeList, calls `filterFn` for each node and removes node\n   * if function returned `true`.\n   *\n   * If function is not passed, removes all the nodes in node list.\n   *\n   * @param NodeList nodeList The no\n   * @param Function filterFn\n   * @return void\n   */\n  _removeNodes: function(nodeList, filterFn) {\n    for (var i = nodeList.length - 1; i >= 0; i--) {\n      var node = nodeList[i];\n      var parentNode = node.parentNode;\n      if (parentNode) {\n        if (!filterFn || filterFn.call(this, node, i, nodeList)) {\n          parentNode.removeChild(node);\n        }\n      }\n    }\n  },\n\n  /**\n   * Iterate over a NodeList, which doesn't natively fully implement the Array\n   * interface.\n   *\n   * For convenience, the current object context is applied to the provided\n   * iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @param  Boolean  backward Whether to use backward iteration.\n   * @return void\n   */\n  _forEachNode: function(nodeList, fn, backward) {\n    Array.prototype.forEach.call(nodeList, fn, this);\n  },\n\n  /**\n   * Iterate over a NodeList, return true if any of the provided iterate\n   * function calls returns true, false otherwise.\n   *\n   * For convenience, the current object context is applied to the\n   * provided iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return Boolean\n   */\n  _someNode: function(nodeList, fn) {\n    return Array.prototype.some.call(nodeList, fn, this);\n  },\n\n  /**\n   * Concat all nodelists passed as arguments.\n   *\n   * @return ...NodeList\n   * @return Array\n   */\n  _concatNodeLists: function() {\n    var slice = Array.prototype.slice;\n    var args = slice.call(arguments);\n    var nodeLists = args.map(function(list) {\n      return slice.call(list);\n    });\n    return Array.prototype.concat.apply([], nodeLists);\n  },\n\n  _getAllNodesWithTag: function(node, tagNames) {\n    if (node.querySelectorAll) {\n      return node.querySelectorAll(tagNames.join(','));\n    }\n    return [].concat.apply([], tagNames.map(function(tag) {\n      var collection = node.getElementsByTagName(tag);\n      return Array.isArray(collection) ? collection : Array.from(collection);\n    }));\n  },\n\n  /**\n   * Converts each <a> and <img> uri in the given element to an absolute URI,\n   * ignoring #ref URIs.\n   *\n   * @param Element\n   * @return void\n   */\n  _fixRelativeUris: function(articleContent) {\n    var scheme = this._uri.scheme;\n    var prePath = this._uri.prePath;\n    var pathBase = this._uri.pathBase;\n\n    function toAbsoluteURI(uri) {\n      // If this is already an absolute URI, return it.\n      if (/^[a-zA-Z][a-zA-Z0-9\\+\\-\\.]*:/.test(uri))\n        return uri;\n\n      // Scheme-rooted relative URI.\n      if (uri.substr(0, 2) == \"//\")\n        return scheme + \"://\" + uri.substr(2);\n\n      // Prepath-rooted relative URI.\n      if (uri[0] == \"/\")\n        return prePath + uri;\n\n      // Dotslash relative URI.\n      if (uri.indexOf(\"./\") === 0)\n        return pathBase + uri.slice(2);\n\n      // Ignore hash URIs:\n      if (uri[0] == \"#\")\n        return uri;\n\n      // Standard relative URI; add entire path. pathBase already includes a\n      // trailing \"/\".\n      return pathBase + uri;\n    }\n\n    var links = articleContent.getElementsByTagName(\"a\");\n    this._forEachNode(links, function(link) {\n      var href = link.getAttribute(\"href\");\n      if (href) {\n        // Replace links with javascript: URIs with text content, since\n        // they won't work after scripts have been removed from the page.\n        if (href.indexOf(\"javascript:\") === 0) {\n          var text = this._doc.createTextNode(link.textContent);\n          link.parentNode.replaceChild(text, link);\n        } else {\n          link.setAttribute(\"href\", toAbsoluteURI(href));\n        }\n      }\n    });\n\n    var imgs = articleContent.getElementsByTagName(\"img\");\n    this._forEachNode(imgs, function(img) {\n      var src = img.getAttribute(\"src\");\n      if (src) {\n        img.setAttribute(\"src\", toAbsoluteURI(src));\n      }\n    });\n  },\n\n  /**\n   * Get the article title as an H1.\n   *\n   * @return void\n   **/\n  _getArticleTitle: function() {\n    var doc = this._doc;\n    var curTitle = \"\";\n    var origTitle = \"\";\n\n    try {\n      curTitle = origTitle = doc.title;\n\n      // If they had an element with id \"title\" in their HTML\n      if (typeof curTitle !== \"string\")\n        curTitle = origTitle = this._getInnerText(doc.getElementsByTagName('title')[0]);\n    } catch (e) {/* ignore exceptions setting the title. */}\n\n    if (curTitle.match(/ [\\|\\-] /)) {\n      curTitle = origTitle.replace(/(.*)[\\|\\-] .*/gi, '$1');\n\n      if (curTitle.split(' ').length < 3)\n        curTitle = origTitle.replace(/[^\\|\\-]*[\\|\\-](.*)/gi, '$1');\n    } else if (curTitle.indexOf(': ') !== -1) {\n      // Check if we have an heading containing this exact string, so we\n      // could assume it's the full title.\n      var headings = this._concatNodeLists(\n        doc.getElementsByTagName('h1'),\n        doc.getElementsByTagName('h2')\n      );\n      var match = this._someNode(headings, function(heading) {\n        return heading.textContent === curTitle;\n      });\n\n      // If we don't, let's extract the title out of the original title string.\n      if (!match) {\n        curTitle = origTitle.substring(origTitle.lastIndexOf(':') + 1);\n\n        // If the title is now too short, try the first colon instead:\n        if (curTitle.split(' ').length < 3)\n          curTitle = origTitle.substring(origTitle.indexOf(':') + 1);\n      }\n    } else if (curTitle.length > 150 || curTitle.length < 15) {\n      var hOnes = doc.getElementsByTagName('h1');\n\n      if (hOnes.length === 1)\n        curTitle = this._getInnerText(hOnes[0]);\n    }\n\n    curTitle = curTitle.trim();\n\n    if (curTitle.split(' ').length <= 4)\n      curTitle = origTitle;\n\n    return curTitle;\n  },\n\n  /**\n   * Prepare the HTML document for readability to scrape it.\n   * This includes things like stripping javascript, CSS, and handling terrible markup.\n   *\n   * @return void\n   **/\n  _prepDocument: function() {\n    var doc = this._doc;\n\n    // Remove all style tags in head\n    this._removeNodes(doc.getElementsByTagName(\"style\"));\n\n    if (doc.body) {\n      this._replaceBrs(doc.body);\n    }\n\n    this._forEachNode(doc.getElementsByTagName(\"font\"), function(fontNode) {\n      this._setNodeTag(fontNode, \"SPAN\");\n    });\n  },\n\n  /**\n   * Finds the next element, starting from the given node, and ignoring\n   * whitespace in between. If the given node is an element, the same node is\n   * returned.\n   */\n  _nextElement: function (node) {\n    var next = node;\n    while (next\n        && (next.nodeType != Node.ELEMENT_NODE)\n        && this.REGEXPS.whitespace.test(next.textContent)) {\n      next = next.nextSibling;\n    }\n    return next;\n  },\n\n  /**\n   * Replaces 2 or more successive <br> elements with a single <p>.\n   * Whitespace between <br> elements are ignored. For example:\n   *   <div>foo<br>bar<br> <br><br>abc</div>\n   * will become:\n   *   <div>foo<br>bar<p>abc</p></div>\n   */\n  _replaceBrs: function (elem) {\n    this._forEachNode(this._getAllNodesWithTag(elem, [\"br\"]), function(br) {\n      var next = br.nextSibling;\n\n      // Whether 2 or more <br> elements have been found and replaced with a\n      // <p> block.\n      var replaced = false;\n\n      // If we find a <br> chain, remove the <br>s until we hit another element\n      // or non-whitespace. This leaves behind the first <br> in the chain\n      // (which will be replaced with a <p> later).\n      while ((next = this._nextElement(next)) && (next.tagName == \"BR\")) {\n        replaced = true;\n        var brSibling = next.nextSibling;\n        next.parentNode.removeChild(next);\n        next = brSibling;\n      }\n\n      // If we removed a <br> chain, replace the remaining <br> with a <p>. Add\n      // all sibling nodes as children of the <p> until we hit another <br>\n      // chain.\n      if (replaced) {\n        var p = this._doc.createElement(\"p\");\n        br.parentNode.replaceChild(p, br);\n\n        next = p.nextSibling;\n        while (next) {\n          // If we've hit another <br><br>, we're done adding children to this <p>.\n          if (next.tagName == \"BR\") {\n            var nextElem = this._nextElement(next);\n            if (nextElem && nextElem.tagName == \"BR\")\n              break;\n          }\n\n          // Otherwise, make this node a child of the new <p>.\n          var sibling = next.nextSibling;\n          p.appendChild(next);\n          next = sibling;\n        }\n      }\n    });\n  },\n\n  _setNodeTag: function (node, tag) {\n    this.log(\"_setNodeTag\", node, tag);\n    if (node.__JSDOMParser__) {\n      node.localName = tag.toLowerCase();\n      node.tagName = tag.toUpperCase();\n      return node;\n    }\n\n    var replacement = node.ownerDocument.createElement(tag);\n    while (node.firstChild) {\n      replacement.appendChild(node.firstChild);\n    }\n    node.parentNode.replaceChild(replacement, node);\n    if (node.readability)\n      replacement.readability = node.readability;\n\n    for (var i = 0; i < node.attributes.length; i++) {\n      replacement.setAttribute(node.attributes[i].name, node.attributes[i].value);\n    }\n    return replacement;\n  },\n\n  /**\n   * Prepare the article node for display. Clean out any inline styles,\n   * iframes, forms, strip extraneous <p> tags, etc.\n   *\n   * @param Element\n   * @return void\n   **/\n  _prepArticle: function(articleContent) {\n    this._cleanStyles(articleContent);\n\n    // Clean out junk from the article content\n    this._cleanConditionally(articleContent, \"form\");\n    this._clean(articleContent, \"object\");\n    this._clean(articleContent, \"embed\");\n    this._clean(articleContent, \"h1\");\n    this._clean(articleContent, \"footer\");\n\n    // If there is only one h2, they are probably using it as a header\n    // and not a subheader, so remove it since we already have a header.\n    if (articleContent.getElementsByTagName('h2').length === 1)\n      this._clean(articleContent, \"h2\");\n\n    this._clean(articleContent, \"iframe\");\n    this._cleanHeaders(articleContent);\n\n    // Do these last as the previous stuff may have removed junk\n    // that will affect these\n    this._cleanConditionally(articleContent, \"table\");\n    this._cleanConditionally(articleContent, \"ul\");\n    this._cleanConditionally(articleContent, \"div\");\n\n    // Remove extra paragraphs\n    this._removeNodes(articleContent.getElementsByTagName('p'), function (paragraph) {\n      var imgCount = paragraph.getElementsByTagName('img').length;\n      var embedCount = paragraph.getElementsByTagName('embed').length;\n      var objectCount = paragraph.getElementsByTagName('object').length;\n      // At this point, nasty iframes have been removed, only remain embedded video ones.\n      var iframeCount = paragraph.getElementsByTagName('iframe').length;\n      var totalCount = imgCount + embedCount + objectCount + iframeCount;\n\n      return totalCount === 0 && !this._getInnerText(paragraph, false);\n    });\n\n    this._forEachNode(this._getAllNodesWithTag(articleContent, [\"br\"]), function(br) {\n      var next = this._nextElement(br.nextSibling);\n      if (next && next.tagName == \"P\")\n        br.parentNode.removeChild(br);\n    });\n  },\n\n  /**\n   * Initialize a node with the readability object. Also checks the\n   * className/id for special names to add to its score.\n   *\n   * @param Element\n   * @return void\n  **/\n  _initializeNode: function(node) {\n    node.readability = {\"contentScore\": 0};\n\n    switch (node.tagName) {\n      case 'DIV':\n        node.readability.contentScore += 5;\n        break;\n\n      case 'PRE':\n      case 'TD':\n      case 'BLOCKQUOTE':\n        node.readability.contentScore += 3;\n        break;\n\n      case 'ADDRESS':\n      case 'OL':\n      case 'UL':\n      case 'DL':\n      case 'DD':\n      case 'DT':\n      case 'LI':\n      case 'FORM':\n        node.readability.contentScore -= 3;\n        break;\n\n      case 'H1':\n      case 'H2':\n      case 'H3':\n      case 'H4':\n      case 'H5':\n      case 'H6':\n      case 'TH':\n        node.readability.contentScore -= 5;\n        break;\n    }\n\n    node.readability.contentScore += this._getClassWeight(node);\n  },\n\n  _removeAndGetNext: function(node) {\n    var nextNode = this._getNextNode(node, true);\n    node.parentNode.removeChild(node);\n    return nextNode;\n  },\n\n  /**\n   * Traverse the DOM from node to node, starting at the node passed in.\n   * Pass true for the second parameter to indicate this node itself\n   * (and its kids) are going away, and we want the next node over.\n   *\n   * Calling this in a loop will traverse the DOM depth-first.\n   */\n  _getNextNode: function(node, ignoreSelfAndKids) {\n    // First check for kids if those aren't being ignored\n    if (!ignoreSelfAndKids && node.firstElementChild) {\n      return node.firstElementChild;\n    }\n    // Then for siblings...\n    if (node.nextElementSibling) {\n      return node.nextElementSibling;\n    }\n    // And finally, move up the parent chain *and* find a sibling\n    // (because this is depth-first traversal, we will have already\n    // seen the parent nodes themselves).\n    do {\n      node = node.parentNode;\n    } while (node && !node.nextElementSibling);\n    return node && node.nextElementSibling;\n  },\n\n  /**\n   * Like _getNextNode, but for DOM implementations with no\n   * firstElementChild/nextElementSibling functionality...\n   */\n  _getNextNodeNoElementProperties: function(node, ignoreSelfAndKids) {\n    function nextSiblingEl(n) {\n      do {\n        n = n.nextSibling;\n      } while (n && n.nodeType !== n.ELEMENT_NODE);\n      return n;\n    }\n    // First check for kids if those aren't being ignored\n    if (!ignoreSelfAndKids && node.children[0]) {\n      return node.children[0];\n    }\n    // Then for siblings...\n    var next = nextSiblingEl(node);\n    if (next) {\n      return next;\n    }\n    // And finally, move up the parent chain *and* find a sibling\n    // (because this is depth-first traversal, we will have already\n    // seen the parent nodes themselves).\n    do {\n      node = node.parentNode;\n      if (node)\n        next = nextSiblingEl(node);\n    } while (node && !next);\n    return node && next;\n  },\n\n  _checkByline: function(node, matchString) {\n    if (this._articleByline) {\n      return false;\n    }\n\n    if (node.getAttribute !== undefined) {\n      var rel = node.getAttribute(\"rel\");\n    }\n\n    if ((rel === \"author\" || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {\n      this._articleByline = node.textContent.trim();\n      return true;\n    }\n\n    return false;\n  },\n\n  _getNodeAncestors: function(node, maxDepth) {\n    maxDepth = maxDepth || 0;\n    var i = 0, ancestors = [];\n    while (node.parentNode) {\n      ancestors.push(node.parentNode);\n      if (maxDepth && ++i === maxDepth)\n        break;\n      node = node.parentNode;\n    }\n    return ancestors;\n  },\n\n  /***\n   * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is\n   *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.\n   *\n   * @param page a document to run upon. Needs to be a full document, complete with body.\n   * @return Element\n  **/\n  _grabArticle: function (page) {\n    this.log(\"**** grabArticle ****\");\n    var doc = this._doc;\n    var isPaging = (page !== null ? true: false);\n    page = page ? page : this._doc.body;\n\n    // We can't grab an article if we don't have a page!\n    if (!page) {\n      this.log(\"No body found in document. Abort.\");\n      return null;\n    }\n\n    var pageCacheHtml = page.innerHTML;\n\n    // Check if any \"dir\" is set on the toplevel document element\n    this._articleDir = doc.documentElement.getAttribute(\"dir\");\n\n    while (true) {\n      var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);\n\n      // First, node prepping. Trash nodes that look cruddy (like ones with the\n      // class name \"comment\", etc), and turn divs into P tags where they have been\n      // used inappropriately (as in, where they contain no other block level elements.)\n      var elementsToScore = [];\n      var node = this._doc.documentElement;\n\n      while (node) {\n        var matchString = node.className + \" \" + node.id;\n\n        // Check to see if this node is a byline, and remove it if it is.\n        if (this._checkByline(node, matchString)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // Remove unlikely candidates\n        if (stripUnlikelyCandidates) {\n          if (this.REGEXPS.unlikelyCandidates.test(matchString) &&\n              !this.REGEXPS.okMaybeItsACandidate.test(matchString) &&\n              node.tagName !== \"BODY\" &&\n              node.tagName !== \"A\") {\n            this.log(\"Removing unlikely candidate - \" + matchString);\n            node = this._removeAndGetNext(node);\n            continue;\n          }\n        }\n\n        if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {\n          elementsToScore.push(node);\n        }\n\n        // Turn all divs that don't have children block level elements into p's\n        if (node.tagName === \"DIV\") {\n          // Sites like http://mobile.slate.com encloses each paragraph with a DIV\n          // element. DIVs with only a P element inside and no text content can be\n          // safely converted into plain P elements to avoid confusing the scoring\n          // algorithm with DIVs with are, in practice, paragraphs.\n          if (this._hasSinglePInsideElement(node)) {\n            var newNode = node.children[0];\n            node.parentNode.replaceChild(newNode, node);\n            node = newNode;\n          } else if (!this._hasChildBlockElement(node)) {\n            node = this._setNodeTag(node, \"P\");\n            elementsToScore.push(node);\n          } else {\n            // EXPERIMENTAL\n            this._forEachNode(node.childNodes, function(childNode) {\n              if (childNode.nodeType === Node.TEXT_NODE) {\n                var p = doc.createElement('p');\n                p.textContent = childNode.textContent;\n                p.style.display = 'inline';\n                p.className = 'readability-styled';\n                node.replaceChild(p, childNode);\n              }\n            });\n          }\n        }\n        node = this._getNextNode(node);\n      }\n\n      /**\n       * Loop through all paragraphs, and assign a score to them based on how content-y they look.\n       * Then add their score to their parent node.\n       *\n       * A score is determined by things like number of commas, class names, etc. Maybe eventually link density.\n      **/\n      var candidates = [];\n      this._forEachNode(elementsToScore, function(elementToScore) {\n        if (!elementToScore.parentNode || typeof(elementToScore.parentNode.tagName) === 'undefined')\n          return;\n\n        // If this paragraph is less than 25 characters, don't even count it.\n        var innerText = this._getInnerText(elementToScore);\n        if (innerText.length < 25)\n          return;\n\n        // Exclude nodes with no ancestor.\n        var ancestors = this._getNodeAncestors(elementToScore, 3);\n        if (ancestors.length === 0)\n          return;\n\n        var contentScore = 0;\n\n        // Add a point for the paragraph itself as a base.\n        contentScore += 1;\n\n        // Add points for any commas within this paragraph.\n        contentScore += innerText.split(',').length;\n\n        // For every 100 characters in this paragraph, add another point. Up to 3 points.\n        contentScore += Math.min(Math.floor(innerText.length / 100), 3);\n\n        // Initialize and score ancestors.\n        this._forEachNode(ancestors, function(ancestor, level) {\n          if (!ancestor.tagName)\n            return;\n\n          if (typeof(ancestor.readability) === 'undefined') {\n            this._initializeNode(ancestor);\n            candidates.push(ancestor);\n          }\n\n          // Node score divider:\n          // - parent:             1 (no division)\n          // - grandparent:        2\n          // - great grandparent+: ancestor level * 3\n          if (level === 0)\n            var scoreDivider = 1;\n          else if (level === 1)\n            scoreDivider = 2;\n          else\n            scoreDivider = level * 3;\n          ancestor.readability.contentScore += contentScore / scoreDivider;\n        });\n      });\n\n      // After we've calculated scores, loop through all of the possible\n      // candidate nodes we found and find the one with the highest score.\n      var topCandidates = [];\n      for (var c = 0, cl = candidates.length; c < cl; c += 1) {\n        var candidate = candidates[c];\n\n        // Scale the final candidates score based on link density. Good content\n        // should have a relatively small link density (5% or less) and be mostly\n        // unaffected by this operation.\n        var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));\n        candidate.readability.contentScore = candidateScore;\n\n        this.log('Candidate:', candidate, \"with score \" + candidateScore);\n\n        for (var t = 0; t < this._nbTopCandidates; t++) {\n          var aTopCandidate = topCandidates[t];\n\n          if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {\n            topCandidates.splice(t, 0, candidate);\n            if (topCandidates.length > this._nbTopCandidates)\n              topCandidates.pop();\n            break;\n          }\n        }\n      }\n\n      var topCandidate = topCandidates[0] || null;\n      var neededToCreateTopCandidate = false;\n\n      // If we still have no top candidate, just use the body as a last resort.\n      // We also have to copy the body node so it is something we can modify.\n      if (topCandidate === null || topCandidate.tagName === \"BODY\") {\n        // Move all of the page's children into topCandidate\n        topCandidate = doc.createElement(\"DIV\");\n        neededToCreateTopCandidate = true;\n        // Move everything (not just elements, also text nodes etc.) into the container\n        // so we even include text directly in the body:\n        var kids = page.childNodes;\n        while (kids.length) {\n          this.log(\"Moving child out:\", kids[0]);\n          topCandidate.appendChild(kids[0]);\n        }\n\n        page.appendChild(topCandidate);\n\n        this._initializeNode(topCandidate);\n      } else if (topCandidate) {\n        // Because of our bonus system, parents of candidates might have scores\n        // themselves. They get half of the node. There won't be nodes with higher\n        // scores than our topCandidate, but if we see the score going *up* in the first\n        // few steps up the tree, that's a decent sign that there might be more content\n        // lurking in other places that we want to unify in. The sibling stuff\n        // below does some of that - but only if we've looked high enough up the DOM\n        // tree.\n        var parentOfTopCandidate = topCandidate.parentNode;\n        var lastScore = topCandidate.readability.contentScore;\n        // The scores shouldn't get too low.\n        var scoreThreshold = lastScore / 3;\n        while (parentOfTopCandidate && parentOfTopCandidate.readability) {\n          var parentScore = parentOfTopCandidate.readability.contentScore;\n          if (parentScore < scoreThreshold)\n            break;\n          if (parentScore > lastScore) {\n            // Alright! We found a better parent to use.\n            topCandidate = parentOfTopCandidate;\n            break;\n          }\n          lastScore = parentOfTopCandidate.readability.contentScore;\n          parentOfTopCandidate = parentOfTopCandidate.parentNode;\n        }\n      }\n\n      // Now that we have the top candidate, look through its siblings for content\n      // that might also be related. Things like preambles, content split by ads\n      // that we removed, etc.\n      var articleContent = doc.createElement(\"DIV\");\n      if (isPaging)\n        articleContent.id = \"readability-content\";\n\n      var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);\n      var siblings = topCandidate.parentNode.children;\n\n      for (var s = 0, sl = siblings.length; s < sl; s++) {\n        var sibling = siblings[s];\n        var append = false;\n\n        this.log(\"Looking at sibling node:\", sibling, sibling.readability ? (\"with score \" + sibling.readability.contentScore) : '');\n        this.log(\"Sibling has score\", sibling.readability ? sibling.readability.contentScore : 'Unknown');\n\n        if (sibling === topCandidate) {\n          append = true;\n        } else {\n          var contentBonus = 0;\n\n          // Give a bonus if sibling nodes and top candidates have the example same classname\n          if (sibling.className === topCandidate.className && topCandidate.className !== \"\")\n            contentBonus += topCandidate.readability.contentScore * 0.2;\n\n          if (sibling.readability &&\n              ((sibling.readability.contentScore + contentBonus) >= siblingScoreThreshold)) {\n            append = true;\n          } else if (sibling.nodeName === \"P\") {\n            var linkDensity = this._getLinkDensity(sibling);\n            var nodeContent = this._getInnerText(sibling);\n            var nodeLength = nodeContent.length;\n\n            if (nodeLength > 80 && linkDensity < 0.25) {\n              append = true;\n            } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 &&\n                       nodeContent.search(/\\.( |$)/) !== -1) {\n              append = true;\n            }\n          }\n        }\n\n        if (append) {\n          this.log(\"Appending node:\", sibling);\n\n          if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {\n            // We have a node that isn't a common block level element, like a form or td tag.\n            // Turn it into a div so it doesn't get filtered out later by accident.\n            this.log(\"Altering sibling:\", sibling, 'to div.');\n\n            sibling = this._setNodeTag(sibling, \"DIV\");\n          }\n\n          articleContent.appendChild(sibling);\n          // siblings is a reference to the children array, and\n          // sibling is removed from the array when we call appendChild().\n          // As a result, we must revisit this index since the nodes\n          // have been shifted.\n          s -= 1;\n          sl -= 1;\n        }\n      }\n\n      if (this._debug)\n        this.log(\"Article content pre-prep: \" + articleContent.innerHTML);\n      // So we have all of the content that we need. Now we clean it up for presentation.\n      this._prepArticle(articleContent);\n      if (this._debug)\n        this.log(\"Article content post-prep: \" + articleContent.innerHTML);\n\n      if (this._curPageNum === 1) {\n        if (neededToCreateTopCandidate) {\n          // We already created a fake div thing, and there wouldn't have been any siblings left\n          // for the previous loop, so there's no point trying to create a new div, and then\n          // move all the children over. Just assign IDs and class names here. No need to append\n          // because that already happened anyway.\n          topCandidate.id = \"readability-page-1\";\n          topCandidate.className = \"page\";\n        } else {\n          var div = doc.createElement(\"DIV\");\n          div.id = \"readability-page-1\";\n          div.className = \"page\";\n          var children = articleContent.childNodes;\n          while (children.length) {\n            div.appendChild(children[0]);\n          }\n          articleContent.appendChild(div);\n        }\n      }\n\n      if (this._debug)\n        this.log(\"Article content after paging: \" + articleContent.innerHTML);\n\n      // Now that we've gone through the full algorithm, check to see if\n      // we got any meaningful content. If we didn't, we may need to re-run\n      // grabArticle with different flags set. This gives us a higher likelihood of\n      // finding the content, and the sieve approach gives us a higher likelihood of\n      // finding the -right- content.\n      if (this._getInnerText(articleContent, true).length < 500) {\n        page.innerHTML = pageCacheHtml;\n\n        if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {\n          this._removeFlag(this.FLAG_STRIP_UNLIKELYS);\n        } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {\n          this._removeFlag(this.FLAG_WEIGHT_CLASSES);\n        } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {\n          this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);\n        } else {\n          return null;\n        }\n      } else {\n        return articleContent;\n      }\n    }\n  },\n\n  /**\n   * Check whether the input string could be a byline.\n   * This verifies that the input is a string, and that the length\n   * is less than 100 chars.\n   *\n   * @param possibleByline {string} - a string to check whether its a byline.\n   * @return Boolean - whether the input string is a byline.\n   */\n  _isValidByline: function(byline) {\n    if (typeof byline == 'string' || byline instanceof String) {\n      byline = byline.trim();\n      return (byline.length > 0) && (byline.length < 100);\n    }\n    return false;\n  },\n\n  /**\n   * Attempts to get excerpt and byline metadata for the article.\n   *\n   * @return Object with optional \"excerpt\" and \"byline\" properties\n   */\n  _getArticleMetadata: function() {\n    var metadata = {};\n    var values = {};\n    var metaElements = this._doc.getElementsByTagName(\"meta\");\n\n    // Match \"description\", or Twitter's \"twitter:description\" (Cards)\n    // in name attribute.\n    var namePattern = /^\\s*((twitter)\\s*:\\s*)?(description|title)\\s*$/gi;\n\n    // Match Facebook's Open Graph title & description properties.\n    var propertyPattern = /^\\s*og\\s*:\\s*(description|title)\\s*$/gi;\n\n    // Find description tags.\n    this._forEachNode(metaElements, function(element) {\n      var elementName = element.getAttribute(\"name\");\n      var elementProperty = element.getAttribute(\"property\");\n\n      if ([elementName, elementProperty].indexOf(\"author\") !== -1) {\n        metadata.byline = element.getAttribute(\"content\");\n        return;\n      }\n\n      var name = null;\n      if (namePattern.test(elementName)) {\n        name = elementName;\n      } else if (propertyPattern.test(elementProperty)) {\n        name = elementProperty;\n      }\n\n      if (name) {\n        var content = element.getAttribute(\"content\");\n        if (content) {\n          // Convert to lowercase and remove any whitespace\n          // so we can match below.\n          name = name.toLowerCase().replace(/\\s/g, '');\n          values[name] = content.trim();\n        }\n      }\n    });\n\n    if (\"description\" in values) {\n      metadata.excerpt = values[\"description\"];\n    } else if (\"og:description\" in values) {\n      // Use facebook open graph description.\n      metadata.excerpt = values[\"og:description\"];\n    } else if (\"twitter:description\" in values) {\n      // Use twitter cards description.\n      metadata.excerpt = values[\"twitter:description\"];\n    }\n\n    if (\"og:title\" in values) {\n      // Use facebook open graph title.\n      metadata.title = values[\"og:title\"];\n    } else if (\"twitter:title\" in values) {\n      // Use twitter cards title.\n      metadata.title = values[\"twitter:title\"];\n    }\n\n    return metadata;\n  },\n\n  /**\n   * Removes script tags from the document.\n   *\n   * @param Element\n  **/\n  _removeScripts: function(doc) {\n    this._removeNodes(doc.getElementsByTagName('script'), function(scriptNode) {\n      scriptNode.nodeValue = \"\";\n      scriptNode.removeAttribute('src');\n      return true;\n    });\n    this._removeNodes(doc.getElementsByTagName('noscript'));\n  },\n\n  /**\n   * Check if this node has only whitespace and a single P element\n   * Returns false if the DIV node contains non-empty text nodes\n   * or if it contains no P or more than 1 element.\n   *\n   * @param Element\n  **/\n  _hasSinglePInsideElement: function(element) {\n    // There should be exactly 1 element child which is a P:\n    if (element.children.length != 1 || element.children[0].tagName !== \"P\") {\n      return false;\n    }\n\n    // And there should be no text nodes with real content\n    return !this._someNode(element.childNodes, function(node) {\n      return node.nodeType === Node.TEXT_NODE &&\n             this.REGEXPS.hasContent.test(node.textContent);\n    });\n  },\n\n  /**\n   * Determine whether element has any children block level elements.\n   *\n   * @param Element\n   */\n  _hasChildBlockElement: function (element) {\n    return this._someNode(element.childNodes, function(node) {\n      return this.DIV_TO_P_ELEMS.indexOf(node.tagName) !== -1 ||\n             this._hasChildBlockElement(node);\n    });\n  },\n\n  /**\n   * Get the inner text of a node - cross browser compatibly.\n   * This also strips out any excess whitespace to be found.\n   *\n   * @param Element\n   * @param Boolean normalizeSpaces (default: true)\n   * @return string\n  **/\n  _getInnerText: function(e, normalizeSpaces) {\n    normalizeSpaces = (typeof normalizeSpaces === 'undefined') ? true : normalizeSpaces;\n    var textContent = e.textContent.trim();\n\n    if (normalizeSpaces) {\n      return textContent.replace(this.REGEXPS.normalize, \" \");\n    }\n    return textContent;\n  },\n\n  /**\n   * Get the number of times a string s appears in the node e.\n   *\n   * @param Element\n   * @param string - what to split on. Default is \",\"\n   * @return number (integer)\n  **/\n  _getCharCount: function(e, s) {\n    s = s || \",\";\n    return this._getInnerText(e).split(s).length - 1;\n  },\n\n  /**\n   * Remove the style attribute on every e and under.\n   * TODO: Test if getElementsByTagName(*) is faster.\n   *\n   * @param Element\n   * @return void\n  **/\n  _cleanStyles: function(e) {\n    e = e || this._doc;\n    if (!e)\n      return;\n    var cur = e.firstChild;\n\n    // Remove any root styles, if we're able.\n    if (typeof e.removeAttribute === 'function' && e.className !== 'readability-styled')\n      e.removeAttribute('style');\n\n    // Go until there are no more child nodes\n    while (cur !== null) {\n      if (cur.nodeType === cur.ELEMENT_NODE) {\n        // Remove style attribute(s) :\n        if (cur.className !== \"readability-styled\")\n          cur.removeAttribute(\"style\");\n\n        this._cleanStyles(cur);\n      }\n\n      cur = cur.nextSibling;\n    }\n  },\n\n  /**\n   * Get the density of links as a percentage of the content\n   * This is the amount of text that is inside a link divided by the total text in the node.\n   *\n   * @param Element\n   * @return number (float)\n  **/\n  _getLinkDensity: function(element) {\n    var textLength = this._getInnerText(element).length;\n    if (textLength === 0)\n      return 0;\n\n    var linkLength = 0;\n\n    // XXX implement _reduceNodeList?\n    this._forEachNode(element.getElementsByTagName(\"a\"), function(linkNode) {\n      linkLength += this._getInnerText(linkNode).length;\n    });\n\n    return linkLength / textLength;\n  },\n\n  /**\n   * Find a cleaned up version of the current URL, to use for comparing links for possible next-pageyness.\n   *\n   * @author Dan Lacy\n   * @return string the base url\n  **/\n  _findBaseUrl: function() {\n    var uri = this._uri;\n    var noUrlParams = uri.path.split(\"?\")[0];\n    var urlSlashes = noUrlParams.split(\"/\").reverse();\n    var cleanedSegments = [];\n    var possibleType = \"\";\n\n    for (var i = 0, slashLen = urlSlashes.length; i < slashLen; i += 1) {\n      var segment = urlSlashes[i];\n\n      // Split off and save anything that looks like a file type.\n      if (segment.indexOf(\".\") !== -1) {\n        possibleType = segment.split(\".\")[1];\n\n        // If the type isn't alpha-only, it's probably not actually a file extension.\n        if (!possibleType.match(/[^a-zA-Z]/))\n          segment = segment.split(\".\")[0];\n      }\n\n      // EW-CMS specific segment replacement. Ugly.\n      // Example: http://www.ew.com/ew/article/0,,20313460_20369436,00.html\n      if (segment.indexOf(',00') !== -1)\n        segment = segment.replace(',00', '');\n\n      // If our first or second segment has anything looking like a page number, remove it.\n      if (segment.match(/((_|-)?p[a-z]*|(_|-))[0-9]{1,2}$/i) && ((i === 1) || (i === 0)))\n        segment = segment.replace(/((_|-)?p[a-z]*|(_|-))[0-9]{1,2}$/i, \"\");\n\n      var del = false;\n\n      // If this is purely a number, and it's the first or second segment,\n      // it's probably a page number. Remove it.\n      if (i < 2 && segment.match(/^\\d{1,2}$/))\n        del = true;\n\n      // If this is the first segment and it's just \"index\", remove it.\n      if (i === 0 && segment.toLowerCase() === \"index\")\n        del = true;\n\n      // If our first or second segment is smaller than 3 characters,\n      // and the first segment was purely alphas, remove it.\n      if (i < 2 && segment.length < 3 && !urlSlashes[0].match(/[a-z]/i))\n        del = true;\n\n      // If it's not marked for deletion, push it to cleanedSegments.\n      if (!del)\n        cleanedSegments.push(segment);\n    }\n\n    // This is our final, cleaned, base article URL.\n    return uri.scheme + \"://\" + uri.host + cleanedSegments.reverse().join(\"/\");\n  },\n\n  /**\n   * Look for any paging links that may occur within the document.\n   *\n   * @param body\n   * @return object (array)\n  **/\n  _findNextPageLink: function(elem) {\n    var uri = this._uri;\n    var possiblePages = {};\n    var allLinks = elem.getElementsByTagName('a');\n    var articleBaseUrl = this._findBaseUrl();\n\n    // Loop through all links, looking for hints that they may be next-page links.\n    // Things like having \"page\" in their textContent, className or id, or being a child\n    // of a node with a page-y className or id.\n    //\n    // Also possible: levenshtein distance? longest common subsequence?\n    //\n    // After we do that, assign each page a score, and\n    for (var i = 0, il = allLinks.length; i < il; i += 1) {\n      var link = allLinks[i];\n      var linkHref = allLinks[i].href.replace(/#.*$/, '').replace(/\\/$/, '');\n\n      // If we've already seen this page, ignore it.\n      if (linkHref === \"\" ||\n        linkHref === articleBaseUrl ||\n        linkHref === uri.spec ||\n        linkHref in this._parsedPages) {\n        continue;\n      }\n\n      // If it's on a different domain, skip it.\n      if (uri.host !== linkHref.split(/\\/+/g)[1])\n        continue;\n\n      var linkText = this._getInnerText(link);\n\n      // If the linkText looks like it's not the next page, skip it.\n      if (linkText.match(this.REGEXPS.extraneous) || linkText.length > 25)\n        continue;\n\n      // If the leftovers of the URL after removing the base URL don't contain\n      // any digits, it's certainly not a next page link.\n      var linkHrefLeftover = linkHref.replace(articleBaseUrl, '');\n      if (!linkHrefLeftover.match(/\\d/))\n        continue;\n\n      if (!(linkHref in possiblePages)) {\n        possiblePages[linkHref] = {\"score\": 0, \"linkText\": linkText, \"href\": linkHref};\n      } else {\n        possiblePages[linkHref].linkText += ' | ' + linkText;\n      }\n\n      var linkObj = possiblePages[linkHref];\n\n      // If the articleBaseUrl isn't part of this URL, penalize this link. It could\n      // still be the link, but the odds are lower.\n      // Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html\n      if (linkHref.indexOf(articleBaseUrl) !== 0)\n        linkObj.score -= 25;\n\n      var linkData = linkText + ' ' + link.className + ' ' + link.id;\n      if (linkData.match(this.REGEXPS.nextLink))\n        linkObj.score += 50;\n\n      if (linkData.match(/pag(e|ing|inat)/i))\n        linkObj.score += 25;\n\n      if (linkData.match(/(first|last)/i)) {\n        // -65 is enough to negate any bonuses gotten from a > or » in the text,\n        // If we already matched on \"next\", last is probably fine.\n        // If we didn't, then it's bad. Penalize.\n        if (!linkObj.linkText.match(this.REGEXPS.nextLink))\n          linkObj.score -= 65;\n      }\n\n      if (linkData.match(this.REGEXPS.negative) || linkData.match(this.REGEXPS.extraneous))\n        linkObj.score -= 50;\n\n      if (linkData.match(this.REGEXPS.prevLink))\n        linkObj.score -= 200;\n\n      // If a parentNode contains page or paging or paginat\n      var parentNode = link.parentNode;\n      var positiveNodeMatch = false;\n      var negativeNodeMatch = false;\n\n      while (parentNode) {\n        var parentNodeClassAndId = parentNode.className + ' ' + parentNode.id;\n\n        if (!positiveNodeMatch && parentNodeClassAndId && parentNodeClassAndId.match(/pag(e|ing|inat)/i)) {\n          positiveNodeMatch = true;\n          linkObj.score += 25;\n        }\n\n        if (!negativeNodeMatch && parentNodeClassAndId && parentNodeClassAndId.match(this.REGEXPS.negative)) {\n          // If this is just something like \"footer\", give it a negative.\n          // If it's something like \"body-and-footer\", leave it be.\n          if (!parentNodeClassAndId.match(this.REGEXPS.positive)) {\n            linkObj.score -= 25;\n            negativeNodeMatch = true;\n          }\n        }\n\n        parentNode = parentNode.parentNode;\n      }\n\n      // If the URL looks like it has paging in it, add to the score.\n      // Things like /page/2/, /pagenum/2, ?p=3, ?page=11, ?pagination=34\n      if (linkHref.match(/p(a|g|ag)?(e|ing|ination)?(=|\\/)[0-9]{1,2}/i) || linkHref.match(/(page|paging)/i))\n        linkObj.score += 25;\n\n      // If the URL contains negative values, give a slight decrease.\n      if (linkHref.match(this.REGEXPS.extraneous))\n        linkObj.score -= 15;\n\n      /**\n       * Minor punishment to anything that doesn't match our current URL.\n       * NOTE: I'm finding this to cause more harm than good where something is exactly 50 points.\n       *     Dan, can you show me a counterexample where this is necessary?\n       * if (linkHref.indexOf(window.location.href) !== 0) {\n       *  linkObj.score -= 1;\n       * }\n      **/\n\n      // If the link text can be parsed as a number, give it a minor bonus, with a slight\n      // bias towards lower numbered pages. This is so that pages that might not have 'next'\n      // in their text can still get scored, and sorted properly by score.\n      var linkTextAsNumber = parseInt(linkText, 10);\n      if (linkTextAsNumber) {\n        // Punish 1 since we're either already there, or it's probably\n        // before what we want anyways.\n        if (linkTextAsNumber === 1) {\n          linkObj.score -= 10;\n        } else {\n          linkObj.score += Math.max(0, 10 - linkTextAsNumber);\n        }\n      }\n    }\n\n    // Loop thrugh all of our possible pages from above and find our top\n    // candidate for the next page URL. Require at least a score of 50, which\n    // is a relatively high confidence that this page is the next link.\n    var topPage = null;\n    for (var page in possiblePages) {\n      if (possiblePages.hasOwnProperty(page)) {\n        if (possiblePages[page].score >= 50 &&\n          (!topPage || topPage.score < possiblePages[page].score))\n          topPage = possiblePages[page];\n      }\n    }\n\n    var nextHref = null;\n    if (topPage) {\n      nextHref = topPage.href.replace(/\\/$/, '');\n\n      this.log('NEXT PAGE IS ' + nextHref);\n      this._parsedPages[nextHref] = true;\n    }\n    return nextHref;\n  },\n\n  _successfulRequest: function(request) {\n    return (request.status >= 200 && request.status < 300) ||\n        request.status === 304 ||\n         (request.status === 0 && request.responseText);\n  },\n\n  _ajax: function(url, options) {\n    var request = new XMLHttpRequest();\n\n    function respondToReadyState(readyState) {\n      if (request.readyState === 4) {\n        if (this._successfulRequest(request)) {\n          if (options.success)\n            options.success(request);\n        } else if (options.error) {\n          options.error(request);\n        }\n      }\n    }\n\n    if (typeof options === 'undefined')\n      options = {};\n\n    request.onreadystatechange = respondToReadyState;\n\n    request.open('get', url, true);\n    request.setRequestHeader('Accept', 'text/html');\n\n    try {\n      request.send(options.postBody);\n    } catch (e) {\n      if (options.error)\n        options.error();\n    }\n\n    return request;\n  },\n\n  _appendNextPage: function(nextPageLink) {\n    var doc = this._doc;\n    this._curPageNum += 1;\n\n    var articlePage = doc.createElement(\"DIV\");\n    articlePage.id = 'readability-page-' + this._curPageNum;\n    articlePage.className = 'page';\n    articlePage.innerHTML = '<p class=\"page-separator\" title=\"Page ' + this._curPageNum + '\">&sect;</p>';\n\n    doc.getElementById(\"readability-content\").appendChild(articlePage);\n\n    if (this._curPageNum > this._maxPages) {\n      var nextPageMarkup = \"<div style='text-align: center'><a href='\" + nextPageLink + \"'>View Next Page</a></div>\";\n      articlePage.innerHTML = articlePage.innerHTML + nextPageMarkup;\n      return;\n    }\n\n    // Now that we've built the article page DOM element, get the page content\n    // asynchronously and load the cleaned content into the div we created for it.\n    (function(pageUrl, thisPage) {\n      this._ajax(pageUrl, {\n        success: function(r) {\n\n          // First, check to see if we have a matching ETag in headers - if we do, this is a duplicate page.\n          var eTag = r.getResponseHeader('ETag');\n          if (eTag) {\n            if (eTag in this._pageETags) {\n              this.log(\"Exact duplicate page found via ETag. Aborting.\");\n              articlePage.style.display = 'none';\n              return;\n            }\n            this._pageETags[eTag] = 1;\n          }\n\n          // TODO: this ends up doubling up page numbers on NYTimes articles. Need to generically parse those away.\n          var page = doc.createElement(\"DIV\");\n\n          // Do some preprocessing to our HTML to make it ready for appending.\n          // - Remove any script tags. Swap and reswap newlines with a unicode\n          //   character because multiline regex doesn't work in javascript.\n          // - Turn any noscript tags into divs so that we can parse them. This\n          //   allows us to find any next page links hidden via javascript.\n          // - Turn all double br's into p's - was handled by prepDocument in the original view.\n          //   Maybe in the future abstract out prepDocument to work for both the original document\n          //   and AJAX-added pages.\n          var responseHtml = r.responseText.replace(/\\n/g, '\\uffff').replace(/<script.*?>.*?<\\/script>/gi, '');\n          responseHtml = responseHtml.replace(/\\n/g, '\\uffff').replace(/<script.*?>.*?<\\/script>/gi, '');\n          responseHtml = responseHtml.replace(/\\uffff/g, '\\n').replace(/<(\\/?)noscript/gi, '<$1div');\n          responseHtml = responseHtml.replace(this.REGEXPS.replaceFonts, '<$1span>');\n\n          page.innerHTML = responseHtml;\n          this._replaceBrs(page);\n\n          // Reset all flags for the next page, as they will search through it and\n          // disable as necessary at the end of grabArticle.\n          this._flags = 0x1 | 0x2 | 0x4;\n\n          var secondNextPageLink = this._findNextPageLink(page);\n\n          // NOTE: if we end up supporting _appendNextPage(), we'll need to\n          // change this call to be async\n          var content = this._grabArticle(page);\n\n          if (!content) {\n            this.log(\"No content found in page to append. Aborting.\");\n            return;\n          }\n\n          // Anti-duplicate mechanism. Essentially, get the first paragraph of our new page.\n          // Compare it against all of the the previous document's we've gotten. If the previous\n          // document contains exactly the innerHTML of this first paragraph, it's probably a duplicate.\n          var firstP = content.getElementsByTagName(\"P\").length ? content.getElementsByTagName(\"P\")[0] : null;\n          if (firstP && firstP.innerHTML.length > 100) {\n            for (var i = 1; i <= this._curPageNum; i += 1) {\n              var rPage = doc.getElementById('readability-page-' + i);\n              if (rPage && rPage.innerHTML.indexOf(firstP.innerHTML) !== -1) {\n                this.log('Duplicate of page ' + i + ' - skipping.');\n                articlePage.style.display = 'none';\n                this._parsedPages[pageUrl] = true;\n                return;\n              }\n            }\n          }\n\n          this._removeScripts(content);\n\n          thisPage.innerHTML = thisPage.innerHTML + content.innerHTML;\n\n          // After the page has rendered, post process the content. This delay is necessary because,\n          // in webkit at least, offsetWidth is not set in time to determine image width. We have to\n          // wait a little bit for reflow to finish before we can fix floating images.\n          setTimeout((function() {\n            this._postProcessContent(thisPage);\n          }).bind(this), 500);\n\n\n          if (secondNextPageLink)\n            this._appendNextPage(secondNextPageLink);\n        }\n      });\n    }).bind(this)(nextPageLink, articlePage);\n  },\n\n  /**\n   * Get an elements class/id weight. Uses regular expressions to tell if this\n   * element looks good or bad.\n   *\n   * @param Element\n   * @return number (Integer)\n  **/\n  _getClassWeight: function(e) {\n    if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES))\n      return 0;\n\n    var weight = 0;\n\n    // Look for a special classname\n    if (typeof(e.className) === 'string' && e.className !== '') {\n      if (this.REGEXPS.negative.test(e.className))\n        weight -= 25;\n\n      if (this.REGEXPS.positive.test(e.className))\n        weight += 25;\n    }\n\n    // Look for a special ID\n    if (typeof(e.id) === 'string' && e.id !== '') {\n      if (this.REGEXPS.negative.test(e.id))\n        weight -= 25;\n\n      if (this.REGEXPS.positive.test(e.id))\n        weight += 25;\n    }\n\n    return weight;\n  },\n\n  /**\n   * Clean a node of all elements of type \"tag\".\n   * (Unless it's a youtube/vimeo video. People love movies.)\n   *\n   * @param Element\n   * @param string tag to clean\n   * @return void\n   **/\n  _clean: function(e, tag) {\n    var isEmbed = [\"object\", \"embed\", \"iframe\"].indexOf(tag) !== -1;\n\n    this._removeNodes(e.getElementsByTagName(tag), function(element) {\n      // Allow youtube and vimeo videos through as people usually want to see those.\n      if (isEmbed) {\n        var attributeValues = [].map.call(element.attributes, function(attr) {\n          return attr.value;\n        }).join(\"|\");\n\n        // First, check the elements attributes to see if any of them contain youtube or vimeo\n        if (this.REGEXPS.videos.test(attributeValues))\n          return false;\n\n        // Then check the elements inside this element for the same.\n        if (this.REGEXPS.videos.test(element.innerHTML))\n          return false;\n      }\n\n      return true;\n    });\n  },\n\n  /**\n   * Check if a given node has one of its ancestor tag name matching the\n   * provided one.\n   * @param  HTMLElement node\n   * @param  String      tagName\n   * @param  Number      maxDepth\n   * @return Boolean\n   */\n  _hasAncestorTag: function(node, tagName, maxDepth) {\n    maxDepth = maxDepth || 3;\n    tagName = tagName.toUpperCase();\n    var depth = 0;\n    while (node.parentNode) {\n      if (depth > maxDepth)\n        return false;\n      if (node.parentNode.tagName === tagName)\n        return true;\n      node = node.parentNode;\n      depth++;\n    }\n    return false;\n  },\n\n  /**\n   * Clean an element of all tags of type \"tag\" if they look fishy.\n   * \"Fishy\" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.\n   *\n   * @return void\n   **/\n  _cleanConditionally: function(e, tag) {\n    if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY))\n      return;\n\n    var isList = tag === \"ul\" || tag === \"ol\";\n\n    // Gather counts for other typical elements embedded within.\n    // Traverse backwards so we can remove nodes at the same time\n    // without effecting the traversal.\n    //\n    // TODO: Consider taking into account original contentScore here.\n    this._removeNodes(e.getElementsByTagName(tag), function(node) {\n      var weight = this._getClassWeight(node);\n      var contentScore = 0;\n\n      this.log(\"Cleaning Conditionally\", node);\n\n      if (weight + contentScore < 0) {\n        return true;\n      }\n\n      if (this._getCharCount(node, ',') < 10) {\n        // If there are not very many commas, and the number of\n        // non-paragraph elements is more than paragraphs or other\n        // ominous signs, remove the element.\n        var p = node.getElementsByTagName(\"p\").length;\n        var img = node.getElementsByTagName(\"img\").length;\n        var li = node.getElementsByTagName(\"li\").length-100;\n        var input = node.getElementsByTagName(\"input\").length;\n\n        var embedCount = 0;\n        var embeds = node.getElementsByTagName(\"embed\");\n        for (var ei = 0, il = embeds.length; ei < il; ei += 1) {\n          if (!this.REGEXPS.videos.test(embeds[ei].src))\n            embedCount += 1;\n        }\n\n        var linkDensity = this._getLinkDensity(node);\n        var contentLength = this._getInnerText(node).length;\n\n        var haveToRemove =\n          // Make an exception for elements with no p's and exactly 1 img.\n          (img > p && !this._hasAncestorTag(node, \"figure\")) ||\n          (!isList && li > p) ||\n          (input > Math.floor(p/3)) ||\n          (!isList && contentLength < 25 && (img === 0 || img > 2)) ||\n          (!isList && weight < 25 && linkDensity > 0.2) ||\n          (weight >= 25 && linkDensity > 0.5) ||\n          ((embedCount === 1 && contentLength < 75) || embedCount > 1);\n        return haveToRemove;\n      }\n      return false;\n    });\n  },\n\n  /**\n   * Clean out spurious headers from an Element. Checks things like classnames and link density.\n   *\n   * @param Element\n   * @return void\n  **/\n  _cleanHeaders: function(e) {\n    for (var headerIndex = 1; headerIndex < 3; headerIndex += 1) {\n      this._removeNodes(e.getElementsByTagName('h' + headerIndex), function (header) {\n        return this._getClassWeight(header) < 0;\n      });\n    }\n  },\n\n  _flagIsActive: function(flag) {\n    return (this._flags & flag) > 0;\n  },\n\n  _addFlag: function(flag) {\n    this._flags = this._flags | flag;\n  },\n\n  _removeFlag: function(flag) {\n    this._flags = this._flags & ~flag;\n  },\n\n  /**\n   * Decides whether or not the document is reader-able without parsing the whole thing.\n   *\n   * @return boolean Whether or not we suspect parse() will suceeed at returning an article object.\n   */\n  isProbablyReaderable: function(helperIsVisible) {\n    var nodes = this._getAllNodesWithTag(this._doc, [\"p\", \"pre\"]);\n\n    // FIXME we should have a fallback for helperIsVisible, but this is\n    // problematic because of jsdom's elem.style handling - see\n    // https://github.com/mozilla/readability/pull/186 for context.\n\n    var score = 0;\n    // This is a little cheeky, we use the accumulator 'score' to decide what to return from\n    // this callback:\n    return this._someNode(nodes, function(node) {\n      if (helperIsVisible && !helperIsVisible(node))\n        return false;\n      var matchString = node.className + \" \" + node.id;\n\n      if (this.REGEXPS.unlikelyCandidates.test(matchString) &&\n          !this.REGEXPS.okMaybeItsACandidate.test(matchString)) {\n        return false;\n      }\n\n      if (node.matches && node.matches(\"li p\")) {\n        return false;\n      }\n\n      var textContentLength = node.textContent.trim().length;\n      if (textContentLength < 140) {\n        return false;\n      }\n\n      score += Math.sqrt(textContentLength - 140);\n\n      if (score > 20) {\n        return true;\n      }\n      return false;\n    });\n  },\n\n  /**\n   * Runs readability.\n   *\n   * Workflow:\n   *  1. Prep the document by removing script tags, css, etc.\n   *  2. Build readability's DOM tree.\n   *  3. Grab the article content from the current dom tree.\n   *  4. Replace the current DOM tree with the new one.\n   *  5. Read peacefully.\n   *\n   * @return void\n   **/\n  parse: function () {\n    // Avoid parsing too large documents, as per configuration option\n    if (this._maxElemsToParse > 0) {\n      var numTags = this._doc.getElementsByTagName(\"*\").length;\n      if (numTags > this._maxElemsToParse) {\n        throw new Error(\"Aborting parsing document; \" + numTags + \" elements found\");\n      }\n    }\n\n    if (typeof this._doc.documentElement.firstElementChild === \"undefined\") {\n      this._getNextNode = this._getNextNodeNoElementProperties;\n    }\n    // Remove script tags from the document.\n    this._removeScripts(this._doc);\n\n    // FIXME: Disabled multi-page article support for now as it\n    // needs more work on infrastructure.\n\n    // Make sure this document is added to the list of parsed pages first,\n    // so we don't double up on the first page.\n    // this._parsedPages[uri.spec.replace(/\\/$/, '')] = true;\n\n    // Pull out any possible next page link first.\n    // var nextPageLink = this._findNextPageLink(doc.body);\n\n    this._prepDocument();\n\n    var metadata = this._getArticleMetadata();\n    var articleTitle = metadata.title || this._getArticleTitle();\n\n    var articleContent = this._grabArticle();\n    if (!articleContent)\n      return null;\n\n    this.log(\"Grabbed: \" + articleContent.innerHTML);\n\n    this._postProcessContent(articleContent);\n\n    // if (nextPageLink) {\n    //   // Append any additional pages after a small timeout so that people\n    //   // can start reading without having to wait for this to finish processing.\n    //   setTimeout((function() {\n    //     this._appendNextPage(nextPageLink);\n    //   }).bind(this), 500);\n    // }\n\n    // If we haven't found an excerpt in the article's metadata, use the article's\n    // first paragraph as the excerpt. This is used for displaying a preview of\n    // the article's content.\n    if (!metadata.excerpt) {\n      var paragraphs = articleContent.getElementsByTagName(\"p\");\n      if (paragraphs.length > 0) {\n        metadata.excerpt = paragraphs[0].textContent.trim();\n      }\n    }\n\n    var textContent = articleContent.textContent;\n    return { uri: this._uri,\n             title: articleTitle,\n             byline: metadata.byline || this._articleByline,\n             dir: this._articleDir,\n             content: articleContent.innerHTML,\n             textContent: textContent,\n             length: textContent.length,\n             excerpt: metadata.excerpt };\n  }\n};\n" +
"/*eslint-env es6:false*/\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * This is a relatively lightweight DOMParser that is safe to use in a web\n * worker. This is far from a complete DOM implementation; however, it should\n * contain the minimal set of functionality necessary for Readability.js.\n *\n * Aside from not implementing the full DOM API, there are other quirks to be\n * aware of when using the JSDOMParser:\n *\n *   1) Properly formed HTML/XML must be used. This means you should be extra\n *      careful when using this parser on anything received directly from an\n *      XMLHttpRequest. Providing a serialized string from an XMLSerializer,\n *      however, should be safe (since the browser's XMLSerializer should\n *      generate valid HTML/XML). Therefore, if parsing a document from an XHR,\n *      the recommended approach is to do the XHR in the main thread, use\n *      XMLSerializer.serializeToString() on the responseXML, and pass the\n *      resulting string to the worker.\n *\n *   2) Live NodeLists are not supported. DOM methods and properties such as\n *      getElementsByTagName() and childNodes return standard arrays. If you\n *      want these lists to be updated when nodes are removed or added to the\n *      document, you must take care to manually update them yourself.\n */\n(function (global) {\n\n  // XML only defines these and the numeric ones:\n\n  var entityTable = {\n    \"lt\": \"<\",\n    \"gt\": \">\",\n    \"amp\": \"&\",\n    \"quot\": '\"',\n    \"apos\": \"'\",\n  };\n\n  var reverseEntityTable = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    \"&\": \"&amp;\",\n    '\"': \"&quot;\",\n    \"'\": \"&apos;\",\n  };\n\n  function encodeTextContentHTML(s) {\n    return s.replace(/[&<>]/g, function(x) {\n      return reverseEntityTable[x];\n    });\n  }\n\n  function encodeHTML(s) {\n    return s.replace(/[&<>'\"]/g, function(x) {\n      return reverseEntityTable[x];\n    });\n  }\n\n  function decodeHTML(str) {\n    return str.replace(/&(quot|amp|apos|lt|gt);/g, function(match, tag) {\n      return entityTable[tag];\n    }).replace(/&#(?:x([0-9a-z]{1,4})|([0-9]{1,4}));/gi, function(match, hex, numStr) {\n      var num = parseInt(hex || numStr, hex ? 16 : 10); // read num\n      return String.fromCharCode(num);\n    });\n  }\n\n  // When a style is set in JS, map it to the corresponding CSS attribute\n  var styleMap = {\n    \"alignmentBaseline\": \"alignment-baseline\",\n    \"background\": \"background\",\n    \"backgroundAttachment\": \"background-attachment\",\n    \"backgroundClip\": \"background-clip\",\n    \"backgroundColor\": \"background-color\",\n    \"backgroundImage\": \"background-image\",\n    \"backgroundOrigin\": \"background-origin\",\n    \"backgroundPosition\": \"background-position\",\n    \"backgroundPositionX\": \"background-position-x\",\n    \"backgroundPositionY\": \"background-position-y\",\n    \"backgroundRepeat\": \"background-repeat\",\n    \"backgroundRepeatX\": \"background-repeat-x\",\n    \"backgroundRepeatY\": \"background-repeat-y\",\n    \"backgroundSize\": \"background-size\",\n    \"baselineShift\": \"baseline-shift\",\n    \"border\": \"border\",\n    \"borderBottom\": \"border-bottom\",\n    \"borderBottomColor\": \"border-bottom-color\",\n    \"borderBottomLeftRadius\": \"border-bottom-left-radius\",\n    \"borderBottomRightRadius\": \"border-bottom-right-radius\",\n    \"borderBottomStyle\": \"border-bottom-style\",\n    \"borderBottomWidth\": \"border-bottom-width\",\n    \"borderCollapse\": \"border-collapse\",\n    \"borderColor\": \"border-color\",\n    \"borderImage\": \"border-image\",\n    \"borderImageOutset\": \"border-image-outset\",\n    \"borderImageRepeat\": \"border-image-repeat\",\n    \"borderImageSlice\": \"border-image-slice\",\n    \"borderImageSource\": \"border-image-source\",\n    \"borderImageWidth\": \"border-image-width\",\n    \"borderLeft\": \"border-left\",\n    \"borderLeftColor\": \"border-left-color\",\n    \"borderLeftStyle\": \"border-left-style\",\n    \"borderLeftWidth\": \"border-left-width\",\n    \"borderRadius\": \"border-radius\",\n    \"borderRight\": \"border-right\",\n    \"borderRightColor\": \"border-right-color\",\n    \"borderRightStyle\": \"border-right-style\",\n    \"borderRightWidth\": \"border-right-width\",\n    \"borderSpacing\": \"border-spacing\",\n    \"borderStyle\": \"border-style\",\n    \"borderTop\": \"border-top\",\n    \"borderTopColor\": \"border-top-color\",\n    \"borderTopLeftRadius\": \"border-top-left-radius\",\n    \"borderTopRightRadius\": \"border-top-right-radius\",\n    \"borderTopStyle\": \"border-top-style\",\n    \"borderTopWidth\": \"border-top-width\",\n    \"borderWidth\": \"border-width\",\n    \"bottom\": \"bottom\",\n    \"boxShadow\": \"box-shadow\",\n    \"boxSizing\": \"box-sizing\",\n    \"captionSide\": \"caption-side\",\n    \"clear\": \"clear\",\n    \"clip\": \"clip\",\n    \"clipPath\": \"clip-path\",\n    \"clipRule\": \"clip-rule\",\n    \"color\": \"color\",\n    \"colorInterpolation\": \"color-interpolation\",\n    \"colorInterpolationFilters\": \"color-interpolation-filters\",\n    \"colorProfile\": \"color-profile\",\n    \"colorRendering\": \"color-rendering\",\n    \"content\": \"content\",\n    \"counterIncrement\": \"counter-increment\",\n    \"counterReset\": \"counter-reset\",\n    \"cursor\": \"cursor\",\n    \"direction\": \"direction\",\n    \"display\": \"display\",\n    \"dominantBaseline\": \"dominant-baseline\",\n    \"emptyCells\": \"empty-cells\",\n    \"enableBackground\": \"enable-background\",\n    \"fill\": \"fill\",\n    \"fillOpacity\": \"fill-opacity\",\n    \"fillRule\": \"fill-rule\",\n    \"filter\": \"filter\",\n    \"cssFloat\": \"float\",\n    \"floodColor\": \"flood-color\",\n    \"floodOpacity\": \"flood-opacity\",\n    \"font\": \"font\",\n    \"fontFamily\": \"font-family\",\n    \"fontSize\": \"font-size\",\n    \"fontStretch\": \"font-stretch\",\n    \"fontStyle\": \"font-style\",\n    \"fontVariant\": \"font-variant\",\n    \"fontWeight\": \"font-weight\",\n    \"glyphOrientationHorizontal\": \"glyph-orientation-horizontal\",\n    \"glyphOrientationVertical\": \"glyph-orientation-vertical\",\n    \"height\": \"height\",\n    \"imageRendering\": \"image-rendering\",\n    \"kerning\": \"kerning\",\n    \"left\": \"left\",\n    \"letterSpacing\": \"letter-spacing\",\n    \"lightingColor\": \"lighting-color\",\n    \"lineHeight\": \"line-height\",\n    \"listStyle\": \"list-style\",\n    \"listStyleImage\": \"list-style-image\",\n    \"listStylePosition\": \"list-style-position\",\n    \"listStyleType\": \"list-style-type\",\n    \"margin\": \"margin\",\n    \"marginBottom\": \"margin-bottom\",\n    \"marginLeft\": \"margin-left\",\n    \"marginRight\": \"margin-right\",\n    \"marginTop\": \"margin-top\",\n    \"marker\": \"marker\",\n    \"markerEnd\": \"marker-end\",\n    \"markerMid\": \"marker-mid\",\n    \"markerStart\": \"marker-start\",\n    \"mask\": \"mask\",\n    \"maxHeight\": \"max-height\",\n    \"maxWidth\": \"max-width\",\n    \"minHeight\": \"min-height\",\n    \"minWidth\": \"min-width\",\n    \"opacity\": \"opacity\",\n    \"orphans\": \"orphans\",\n    \"outline\": \"outline\",\n    \"outlineColor\": \"outline-color\",\n    \"outlineOffset\": \"outline-offset\",\n    \"outlineStyle\": \"outline-style\",\n    \"outlineWidth\": \"outline-width\",\n    \"overflow\": \"overflow\",\n    \"overflowX\": \"overflow-x\",\n    \"overflowY\": \"overflow-y\",\n    \"padding\": \"padding\",\n    \"paddingBottom\": \"padding-bottom\",\n    \"paddingLeft\": \"padding-left\",\n    \"paddingRight\": \"padding-right\",\n    \"paddingTop\": \"padding-top\",\n    \"page\": \"page\",\n    \"pageBreakAfter\": \"page-break-after\",\n    \"pageBreakBefore\": \"page-break-before\",\n    \"pageBreakInside\": \"page-break-inside\",\n    \"pointerEvents\": \"pointer-events\",\n    \"position\": \"position\",\n    \"quotes\": \"quotes\",\n    \"resize\": \"resize\",\n    \"right\": \"right\",\n    \"shapeRendering\": \"shape-rendering\",\n    \"size\": \"size\",\n    \"speak\": \"speak\",\n    \"src\": \"src\",\n    \"stopColor\": \"stop-color\",\n    \"stopOpacity\": \"stop-opacity\",\n    \"stroke\": \"stroke\",\n    \"strokeDasharray\": \"stroke-dasharray\",\n    \"strokeDashoffset\": \"stroke-dashoffset\",\n    \"strokeLinecap\": \"stroke-linecap\",\n    \"strokeLinejoin\": \"stroke-linejoin\",\n    \"strokeMiterlimit\": \"stroke-miterlimit\",\n    \"strokeOpacity\": \"stroke-opacity\",\n    \"strokeWidth\": \"stroke-width\",\n    \"tableLayout\": \"table-layout\",\n    \"textAlign\": \"text-align\",\n    \"textAnchor\": \"text-anchor\",\n    \"textDecoration\": \"text-decoration\",\n    \"textIndent\": \"text-indent\",\n    \"textLineThrough\": \"text-line-through\",\n    \"textLineThroughColor\": \"text-line-through-color\",\n    \"textLineThroughMode\": \"text-line-through-mode\",\n    \"textLineThroughStyle\": \"text-line-through-style\",\n    \"textLineThroughWidth\": \"text-line-through-width\",\n    \"textOverflow\": \"text-overflow\",\n    \"textOverline\": \"text-overline\",\n    \"textOverlineColor\": \"text-overline-color\",\n    \"textOverlineMode\": \"text-overline-mode\",\n    \"textOverlineStyle\": \"text-overline-style\",\n    \"textOverlineWidth\": \"text-overline-width\",\n    \"textRendering\": \"text-rendering\",\n    \"textShadow\": \"text-shadow\",\n    \"textTransform\": \"text-transform\",\n    \"textUnderline\": \"text-underline\",\n    \"textUnderlineColor\": \"text-underline-color\",\n    \"textUnderlineMode\": \"text-underline-mode\",\n    \"textUnderlineStyle\": \"text-underline-style\",\n    \"textUnderlineWidth\": \"text-underline-width\",\n    \"top\": \"top\",\n    \"unicodeBidi\": \"unicode-bidi\",\n    \"unicodeRange\": \"unicode-range\",\n    \"vectorEffect\": \"vector-effect\",\n    \"verticalAlign\": \"vertical-align\",\n    \"visibility\": \"visibility\",\n    \"whiteSpace\": \"white-space\",\n    \"widows\": \"widows\",\n    \"width\": \"width\",\n    \"wordBreak\": \"word-break\",\n    \"wordSpacing\": \"word-spacing\",\n    \"wordWrap\": \"word-wrap\",\n    \"writingMode\": \"writing-mode\",\n    \"zIndex\": \"z-index\",\n    \"zoom\": \"zoom\",\n  };\n\n  // Elements that can be self-closing\n  var voidElems = {\n    \"area\": true,\n    \"base\": true,\n    \"br\": true,\n    \"col\": true,\n    \"command\": true,\n    \"embed\": true,\n    \"hr\": true,\n    \"img\": true,\n    \"input\": true,\n    \"link\": true,\n    \"meta\": true,\n    \"param\": true,\n    \"source\": true,\n    \"wbr\": true\n  };\n\n  var whitespace = [\" \", \"\\t\", \"\\n\", \"\\r\"];\n\n  // See http://www.w3schools.com/dom/dom_nodetype.asp\n  var nodeTypes = {\n    ELEMENT_NODE: 1,\n    ATTRIBUTE_NODE: 2,\n    TEXT_NODE: 3,\n    CDATA_SECTION_NODE: 4,\n    ENTITY_REFERENCE_NODE: 5,\n    ENTITY_NODE: 6,\n    PROCESSING_INSTRUCTION_NODE: 7,\n    COMMENT_NODE: 8,\n    DOCUMENT_NODE: 9,\n    DOCUMENT_TYPE_NODE: 10,\n    DOCUMENT_FRAGMENT_NODE: 11,\n    NOTATION_NODE: 12\n  };\n\n  function getElementsByTagName(tag) {\n    tag = tag.toUpperCase();\n    var elems = [];\n    var allTags = (tag === \"*\");\n    function getElems(node) {\n      var length = node.children.length;\n      for (var i = 0; i < length; i++) {\n        var child = node.children[i];\n        if (allTags || (child.tagName === tag))\n          elems.push(child);\n        getElems(child);\n      }\n    }\n    getElems(this);\n    return elems;\n  }\n\n  var Node = function () {};\n\n  Node.prototype = {\n    attributes: null,\n    childNodes: null,\n    localName: null,\n    nodeName: null,\n    parentNode: null,\n    textContent: null,\n    nextSibling: null,\n    previousSibling: null,\n\n    get firstChild() {\n      return this.childNodes[0] || null;\n    },\n\n    get firstElementChild() {\n      return this.children[0] || null;\n    },\n\n    get lastChild() {\n      return this.childNodes[this.childNodes.length - 1] || null;\n    },\n\n    get lastElementChild() {\n      return this.children[this.children.length - 1] || null;\n    },\n\n    appendChild: function (child) {\n      if (child.parentNode) {\n        child.parentNode.removeChild(child);\n      }\n\n      var last = this.lastChild;\n      if (last)\n        last.nextSibling = child;\n      child.previousSibling = last;\n\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        child.previousElementSibling = this.children[this.children.length - 1] || null;\n        this.children.push(child);\n        child.previousElementSibling && (child.previousElementSibling.nextElementSibling = child);\n      }\n      this.childNodes.push(child);\n      child.parentNode = this;\n    },\n\n    removeChild: function (child) {\n      var childNodes = this.childNodes;\n      var childIndex = childNodes.indexOf(child);\n      if (childIndex === -1) {\n        throw \"removeChild: node not found\";\n      } else {\n        child.parentNode = null;\n        var prev = child.previousSibling;\n        var next = child.nextSibling;\n        if (prev)\n          prev.nextSibling = next;\n        if (next)\n          next.previousSibling = prev;\n\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          prev = child.previousElementSibling;\n          next = child.nextElementSibling;\n          if (prev)\n            prev.nextElementSibling = next;\n          if (next)\n            next.previousElementSibling = prev;\n          this.children.splice(this.children.indexOf(child), 1);\n        }\n\n        child.previousSibling = child.nextSibling = null;\n        child.previousElementSibling = child.nextElementSibling = null;\n\n        return childNodes.splice(childIndex, 1)[0];\n      }\n    },\n\n    replaceChild: function (newNode, oldNode) {\n      var childNodes = this.childNodes;\n      var childIndex = childNodes.indexOf(oldNode);\n      if (childIndex === -1) {\n        throw \"replaceChild: node not found\";\n      } else {\n        // This will take care of updating the new node if it was somewhere else before:\n        if (newNode.parentNode)\n          newNode.parentNode.removeChild(newNode);\n\n        childNodes[childIndex] = newNode;\n\n        // update the new node's sibling properties, and its new siblings' sibling properties\n        newNode.nextSibling = oldNode.nextSibling;\n        newNode.previousSibling = oldNode.previousSibling;\n        if (newNode.nextSibling)\n          newNode.nextSibling.previousSibling = newNode;\n        if (newNode.previousSibling)\n          newNode.previousSibling.nextSibling = newNode;\n\n        newNode.parentNode = this;\n\n        // Now deal with elements before we clear out those values for the old node,\n        // because it can help us take shortcuts here:\n        if (newNode.nodeType === Node.ELEMENT_NODE) {\n          if (oldNode.nodeType === Node.ELEMENT_NODE) {\n            // Both were elements, which makes this easier, we just swap things out:\n            newNode.previousElementSibling = oldNode.previousElementSibling;\n            newNode.nextElementSibling = oldNode.nextElementSibling;\n            if (newNode.previousElementSibling)\n              newNode.previousElementSibling.nextElementSibling = newNode;\n            if (newNode.nextElementSibling)\n              newNode.nextElementSibling.previousElementSibling = newNode;\n            this.children[this.children.indexOf(oldNode)] = newNode;\n          } else {\n            // Hard way:\n            newNode.previousElementSibling = (function() {\n              for (var i = childIndex - 1; i >= 0; i--) {\n                if (childNodes[i].nodeType === Node.ELEMENT_NODE)\n                  return childNodes[i];\n              }\n              return null;\n            })();\n            if (newNode.previousElementSibling) {\n              newNode.nextElementSibling = newNode.previousElementSibling.nextElementSibling;\n            } else {\n              newNode.nextElementSibling = (function() {\n                for (var i = childIndex + 1; i < childNodes.length; i++) {\n                  if (childNodes[i].nodeType === Node.ELEMENT_NODE)\n                    return childNodes[i];\n                }\n                return null;\n              })();\n            }\n            if (newNode.previousElementSibling)\n              newNode.previousElementSibling.nextElementSibling = newNode;\n            if (newNode.nextElementSibling)\n              newNode.nextElementSibling.previousElementSibling = newNode;\n\n            if (newNode.nextElementSibling)\n              this.children.splice(this.children.indexOf(newNode.nextElementSibling), 0, newNode);\n            else\n              this.children.push(newNode);\n          }\n        } else if (oldNode.nodeType === Node.ELEMENT_NODE) {\n          // new node is not an element node.\n          // if the old one was, update its element siblings:\n          if (oldNode.previousElementSibling)\n            oldNode.previousElementSibling.nextElementSibling = oldNode.nextElementSibling;\n          if (oldNode.nextElementSibling)\n            oldNode.nextElementSibling.previousElementSibling = oldNode.previousElementSibling;\n          this.children.splice(this.children.indexOf(oldNode), 1);\n\n          // If the old node wasn't an element, neither the new nor the old node was an element,\n          // and the children array and its members shouldn't need any updating.\n        }\n\n\n        oldNode.parentNode = null;\n        oldNode.previousSibling = null;\n        oldNode.nextSibling = null;\n        if (oldNode.nodeType === Node.ELEMENT_NODE) {\n          oldNode.previousElementSibling = null;\n          oldNode.nextElementSibling = null;\n        }\n        return oldNode;\n      }\n    },\n\n    __JSDOMParser__: true,\n  };\n\n  for (var nodeType in nodeTypes) {\n    Node[nodeType] = Node.prototype[nodeType] = nodeTypes[nodeType];\n  }\n\n  var Attribute = function (name, value) {\n    this.name = name;\n    this._value = value;\n  };\n\n  Attribute.prototype = {\n    get value() {\n      return this._value;\n    },\n    setValue: function(newValue) {\n      this._value = newValue;\n      delete this._decodedValue;\n    },\n    setDecodedValue: function(newValue) {\n      this._value = encodeHTML(newValue);\n      this._decodedValue = newValue;\n    },\n    getDecodedValue: function() {\n      if (typeof this._decodedValue === \"undefined\") {\n        this._decodedValue = (this._value && decodeHTML(this._value)) || \"\";\n      }\n      return this._decodedValue;\n    },\n  };\n\n  var Comment = function () {\n    this.childNodes = [];\n  };\n\n  Comment.prototype = {\n    __proto__: Node.prototype,\n\n    nodeName: \"#comment\",\n    nodeType: Node.COMMENT_NODE\n  };\n\n  var Text = function () {\n    this.childNodes = [];\n  };\n\n  Text.prototype = {\n    __proto__: Node.prototype,\n\n    nodeName: \"#text\",\n    nodeType: Node.TEXT_NODE,\n    get textContent() {\n      if (typeof this._textContent === \"undefined\") {\n        this._textContent = decodeHTML(this._innerHTML || \"\");\n      }\n      return this._textContent;\n    },\n    get innerHTML() {\n      if (typeof this._innerHTML === \"undefined\") {\n        this._innerHTML = encodeTextContentHTML(this._textContent || \"\");\n      }\n      return this._innerHTML;\n    },\n\n    set innerHTML(newHTML) {\n      this._innerHTML = newHTML;\n      delete this._textContent;\n    },\n    set textContent(newText) {\n      this._textContent = newText;\n      delete this._innerHTML;\n    },\n  };\n\n  var Document = function () {\n    this.styleSheets = [];\n    this.childNodes = [];\n    this.children = [];\n  };\n\n  Document.prototype = {\n    __proto__: Node.prototype,\n\n    nodeName: \"#document\",\n    nodeType: Node.DOCUMENT_NODE,\n    title: \"\",\n\n    getElementsByTagName: getElementsByTagName,\n\n    getElementById: function (id) {\n      function getElem(node) {\n        var length = node.children.length;\n        if (node.id === id)\n          return node;\n        for (var i = 0; i < length; i++) {\n          var el = getElem(node.children[i]);\n          if (el)\n            return el;\n        }\n        return null;\n      }\n      return getElem(this);\n    },\n\n    createElement: function (tag) {\n      var node = new Element(tag);\n      return node;\n    },\n\n    createTextNode: function (text) {\n      var node = new Text();\n      node.textContent = text;\n      return node;\n    },\n  };\n\n  var Element = function (tag) {\n    this.attributes = [];\n    this.childNodes = [];\n    this.children = [];\n    this.nextElementSibling = this.previousElementSibling = null;\n    this.localName = tag.toLowerCase();\n    this.tagName = tag.toUpperCase();\n    this.style = new Style(this);\n  };\n\n  Element.prototype = {\n    __proto__: Node.prototype,\n\n    nodeType: Node.ELEMENT_NODE,\n\n    getElementsByTagName: getElementsByTagName,\n\n    get className() {\n      return this.getAttribute(\"class\") || \"\";\n    },\n\n    set className(str) {\n      this.setAttribute(\"class\", str);\n    },\n\n    get id() {\n      return this.getAttribute(\"id\") || \"\";\n    },\n\n    set id(str) {\n      this.setAttribute(\"id\", str);\n    },\n\n    get href() {\n      return this.getAttribute(\"href\") || \"\";\n    },\n\n    set href(str) {\n      this.setAttribute(\"href\", str);\n    },\n\n    get src() {\n      return this.getAttribute(\"src\") || \"\";\n    },\n\n    set src(str) {\n      this.setAttribute(\"src\", str);\n    },\n\n    get nodeName() {\n      return this.tagName;\n    },\n\n    get innerHTML() {\n      function getHTML(node) {\n        var i = 0;\n        for (i = 0; i < node.childNodes.length; i++) {\n          var child = node.childNodes[i];\n          if (child.localName) {\n            arr.push(\"<\" + child.localName);\n\n            // serialize attribute list\n            for (var j = 0; j < child.attributes.length; j++) {\n              var attr = child.attributes[j];\n              // the attribute value will be HTML escaped.\n              var val = attr.value;\n              var quote = (val.indexOf('\"') === -1 ? '\"' : \"'\");\n              arr.push(\" \" + attr.name + '=' + quote + val + quote);\n            }\n\n            if (child.localName in voidElems && !child.childNodes.length) {\n              // if this is a self-closing element, end it here\n              arr.push(\"/>\");\n            } else {\n              // otherwise, add its children\n              arr.push(\">\");\n              getHTML(child);\n              arr.push(\"</\" + child.localName + \">\");\n            }\n          } else {\n            // This is a text node, so asking for innerHTML won't recurse.\n            arr.push(child.innerHTML);\n          }\n        }\n      }\n\n      // Using Array.join() avoids the overhead from lazy string concatenation.\n      // See http://blog.cdleary.com/2012/01/string-representation-in-spidermonkey/#ropes\n      var arr = [];\n      getHTML(this);\n      return arr.join(\"\");\n    },\n\n    set innerHTML(html) {\n      var parser = new JSDOMParser();\n      var node = parser.parse(html);\n      var i;\n      for (i = this.childNodes.length; --i >= 0;) {\n        this.childNodes[i].parentNode = null;\n      }\n      this.childNodes = node.childNodes;\n      this.children = node.children;\n      for (i = this.childNodes.length; --i >= 0;) {\n        this.childNodes[i].parentNode = this;\n      }\n    },\n\n    set textContent(text) {\n      // clear parentNodes for existing children\n      for (var i = this.childNodes.length; --i >= 0;) {\n        this.childNodes[i].parentNode = null;\n      }\n\n      var node = new Text();\n      this.childNodes = [ node ];\n      this.children = [];\n      node.textContent = text;\n      node.parentNode = this;\n    },\n\n    get textContent() {\n      function getText(node) {\n        var nodes = node.childNodes;\n        for (var i = 0; i < nodes.length; i++) {\n          var child = nodes[i];\n          if (child.nodeType === 3) {\n            text.push(child.textContent);\n          } else {\n            getText(child);\n          }\n        }\n      }\n\n      // Using Array.join() avoids the overhead from lazy string concatenation.\n      // See http://blog.cdleary.com/2012/01/string-representation-in-spidermonkey/#ropes\n      var text = [];\n      getText(this);\n      return text.join(\"\");\n    },\n\n    getAttribute: function (name) {\n      for (var i = this.attributes.length; --i >= 0;) {\n        var attr = this.attributes[i];\n        if (attr.name === name)\n          return attr.getDecodedValue();\n      }\n      return undefined;\n    },\n\n    setAttribute: function (name, value) {\n      for (var i = this.attributes.length; --i >= 0;) {\n        var attr = this.attributes[i];\n        if (attr.name === name) {\n          attr.setDecodedValue(value);\n          return;\n        }\n      }\n      this.attributes.push(new Attribute(name, encodeHTML(value)));\n    },\n\n    removeAttribute: function (name) {\n      for (var i = this.attributes.length; --i >= 0;) {\n        var attr = this.attributes[i];\n        if (attr.name === name) {\n          this.attributes.splice(i, 1);\n          break;\n        }\n      }\n    }\n  };\n\n  var Style = function (node) {\n    this.node = node;\n  };\n\n  // getStyle() and setStyle() use the style attribute string directly. This\n  // won't be very efficient if there are a lot of style manipulations, but\n  // it's the easiest way to make sure the style attribute string and the JS\n  // style property stay in sync. Readability.js doesn't do many style\n  // manipulations, so this should be okay.\n  Style.prototype = {\n    getStyle: function (styleName) {\n      var attr = this.node.getAttribute(\"style\");\n      if (!attr)\n        return undefined;\n\n      var styles = attr.split(\";\");\n      for (var i = 0; i < styles.length; i++) {\n        var style = styles[i].split(\":\");\n        var name = style[0].trim();\n        if (name === styleName)\n          return style[1].trim();\n      }\n\n      return undefined;\n    },\n\n    setStyle: function (styleName, styleValue) {\n      var value = this.node.getAttribute(\"style\") || \"\";\n      var index = 0;\n      do {\n        var next = value.indexOf(\";\", index) + 1;\n        var length = next - index - 1;\n        var style = (length > 0 ? value.substr(index, length) : value.substr(index));\n        if (style.substr(0, style.indexOf(\":\")).trim() === styleName) {\n          value = value.substr(0, index).trim() + (next ? \" \" + value.substr(next).trim() : \"\");\n          break;\n        }\n        index = next;\n      } while (index);\n\n      value += \" \" + styleName + \": \" + styleValue + \";\";\n      this.node.setAttribute(\"style\", value.trim());\n    }\n  };\n\n  // For each item in styleMap, define a getter and setter on the style\n  // property.\n  for (var jsName in styleMap) {\n    (function (cssName) {\n      Style.prototype.__defineGetter__(jsName, function () {\n        return this.getStyle(cssName);\n      });\n      Style.prototype.__defineSetter__(jsName, function (value) {\n        this.setStyle(cssName, value);\n      });\n    })(styleMap[jsName]);\n  }\n\n  var JSDOMParser = function parser() {\n    this.currentChar = 0;\n\n    // In makeElementNode() we build up many strings one char at a time. Using\n    // += for this results in lots of short-lived intermediate strings. It's\n    // better to build an array of single-char strings and then join() them\n    // together at the end. And reusing a single array (i.e. |this.strBuf|)\n    // over and over for this purpose uses less memory than using a new array\n    // for each string.\n    this.strBuf = [];\n\n    // Similarly, we reuse this array to return the two arguments from\n    // makeElementNode(), which saves us from having to allocate a new array\n    // every time.\n    this.retPair = [];\n\n    this.errorState = \"\";\n  };\n\n  JSDOMParser.prototype = {\n    error: function(m) {\n      dump(\"JSDOMParser error: \" + m + \"\\n\");\n      this.errorState += m + \"\\n\";\n    },\n\n    /**\n     * Look at the next character without advancing the index.\n     */\n    peekNext: function () {\n      return this.html[this.currentChar];\n    },\n\n    /**\n     * Get the next character and advance the index.\n     */\n    nextChar: function () {\n      return this.html[this.currentChar++];\n    },\n\n    /**\n     * Called after a quote character is read. This finds the next quote\n     * character and returns the text string in between.\n     */\n    readString: function (quote) {\n      var str;\n      var n = this.html.indexOf(quote, this.currentChar);\n      if (n === -1) {\n        this.currentChar = this.html.length;\n        str = null;\n      } else {\n        str = this.html.substring(this.currentChar, n);\n        this.currentChar = n + 1;\n      }\n\n      return str;\n    },\n\n    /**\n     * Called when parsing a node. This finds the next name/value attribute\n     * pair and adds the result to the attributes list.\n     */\n    readAttribute: function (node) {\n      var name = \"\";\n\n      var n = this.html.indexOf(\"=\", this.currentChar);\n      if (n === -1) {\n        this.currentChar = this.html.length;\n      } else {\n        // Read until a '=' character is hit; this will be the attribute key\n        name = this.html.substring(this.currentChar, n);\n        this.currentChar = n + 1;\n      }\n\n      if (!name)\n        return;\n\n      // After a '=', we should see a '\"' for the attribute value\n      var c = this.nextChar();\n      if (c !== '\"' && c !== \"'\") {\n        this.error(\"Error reading attribute \" + name + \", expecting '\\\"'\");\n        return;\n      }\n\n      // Read the attribute value (and consume the matching quote)\n      var value = this.readString(c);\n\n      node.attributes.push(new Attribute(name, value));\n\n      return;\n    },\n\n    /**\n     * Parses and returns an Element node. This is called after a '<' has been\n     * read.\n     *\n     * @returns an array; the first index of the array is the parsed node;\n     *          the second index is a boolean indicating whether this is a void\n     *          Element\n     */\n    makeElementNode: function (retPair) {\n      var c = this.nextChar();\n\n      // Read the Element tag name\n      var strBuf = this.strBuf;\n      strBuf.length = 0;\n      while (whitespace.indexOf(c) == -1 && c !== \">\" && c !== \"/\") {\n        if (c === undefined)\n          return false;\n        strBuf.push(c);\n        c = this.nextChar();\n      }\n      var tag = strBuf.join('');\n\n      if (!tag)\n        return false;\n\n      var node = new Element(tag);\n\n      // Read Element attributes\n      while (c !== \"/\" && c !== \">\") {\n        if (c === undefined)\n          return false;\n        while (whitespace.indexOf(this.html[this.currentChar++]) != -1);\n        this.currentChar--;\n        c = this.nextChar();\n        if (c !== \"/\" && c !== \">\") {\n          --this.currentChar;\n          this.readAttribute(node);\n        }\n      }\n\n      // If this is a self-closing tag, read '/>'\n      var closed = false;\n      if (c === \"/\") {\n        closed = true;\n        c = this.nextChar();\n        if (c !== \">\") {\n          this.error(\"expected '>' to close \" + tag);\n          return false;\n        }\n      }\n\n      retPair[0] = node;\n      retPair[1] = closed;\n      return true;\n    },\n\n    /**\n     * If the current input matches this string, advance the input index;\n     * otherwise, do nothing.\n     *\n     * @returns whether input matched string\n     */\n    match: function (str) {\n      var strlen = str.length;\n      if (this.html.substr(this.currentChar, strlen).toLowerCase() === str.toLowerCase()) {\n        this.currentChar += strlen;\n        return true;\n      }\n      return false;\n    },\n\n    /**\n     * Searches the input until a string is found and discards all input up to\n     * and including the matched string.\n     */\n    discardTo: function (str) {\n      var index = this.html.indexOf(str, this.currentChar) + str.length;\n      if (index === -1)\n        this.currentChar = this.html.length;\n      this.currentChar = index;\n    },\n\n    /**\n     * Reads child nodes for the given node.\n     */\n    readChildren: function (node) {\n      var child;\n      while ((child = this.readNode())) {\n        // Don't keep Comment nodes\n        if (child.nodeType !== 8) {\n          node.appendChild(child);\n        }\n      }\n    },\n\n    readScript: function (node) {\n      while (this.currentChar < this.html.length) {\n        var c = this.nextChar();\n        var nextC = this.peekNext();\n        if (c === \"<\") {\n          if (nextC === \"!\" || nextC === \"?\") {\n            // We're still before the ! or ? that is starting this comment:\n            this.currentChar++;\n            node.appendChild(this.discardNextComment());\n            continue;\n          }\n          if (nextC === \"/\" && this.html.substr(this.currentChar, 8 /*\"/script>\".length */).toLowerCase() == \"/script>\") {\n            // Go back before the '<' so we find the end tag.\n            this.currentChar--;\n            // Done with this script tag, the caller will close:\n            return;\n          }\n        }\n        // Either c wasn't a '<' or it was but we couldn't find either a comment\n        // or a closing script tag, so we should just parse as text until the next one\n        // comes along:\n\n        var haveTextNode = node.lastChild && node.lastChild.nodeType === Node.TEXT_NODE;\n        var textNode = haveTextNode ? node.lastChild : new Text();\n        var n = this.html.indexOf(\"<\", this.currentChar);\n        // Decrement this to include the current character *afterwards* so we don't get stuck\n        // looking for the same < all the time.\n        this.currentChar--;\n        if (n === -1) {\n          textNode.innerHTML += this.html.substring(this.currentChar, this.html.length);\n          this.currentChar = this.html.length;\n        } else {\n          textNode.innerHTML += this.html.substring(this.currentChar, n);\n          this.currentChar = n;\n        }\n        if (!haveTextNode)\n          node.appendChild(textNode);\n      }\n    },\n\n    discardNextComment: function() {\n      if (this.match(\"--\")) {\n        this.discardTo(\"-->\");\n      } else {\n        var c = this.nextChar();\n        while (c !== \">\") {\n          if (c === undefined)\n            return null;\n          if (c === '\"' || c === \"'\")\n            this.readString(c);\n          c = this.nextChar();\n        }\n      }\n      return new Comment();\n    },\n\n\n    /**\n     * Reads the next child node from the input. If we're reading a closing\n     * tag, or if we've reached the end of input, return null.\n     *\n     * @returns the node\n     */\n    readNode: function () {\n      var c = this.nextChar();\n\n      if (c === undefined)\n        return null;\n\n      // Read any text as Text node\n      if (c !== \"<\") {\n        --this.currentChar;\n        var textNode = new Text();\n        var n = this.html.indexOf(\"<\", this.currentChar);\n        if (n === -1) {\n          textNode.innerHTML = this.html.substring(this.currentChar, this.html.length);\n          this.currentChar = this.html.length;\n        } else {\n          textNode.innerHTML = this.html.substring(this.currentChar, n);\n          this.currentChar = n;\n        }\n        return textNode;\n      }\n\n      c = this.peekNext();\n\n      // Read Comment node. Normally, Comment nodes know their inner\n      // textContent, but we don't really care about Comment nodes (we throw\n      // them away in readChildren()). So just returning an empty Comment node\n      // here is sufficient.\n      if (c === \"!\" || c === \"?\") {\n        // We're still before the ! or ? that is starting this comment:\n        this.currentChar++;\n        return this.discardNextComment();\n      }\n\n      // If we're reading a closing tag, return null. This means we've reached\n      // the end of this set of child nodes.\n      if (c === \"/\") {\n        --this.currentChar;\n        return null;\n      }\n\n      // Otherwise, we're looking at an Element node\n      var result = this.makeElementNode(this.retPair);\n      if (!result)\n        return null;\n\n      var node = this.retPair[0];\n      var closed = this.retPair[1];\n      var localName = node.localName;\n\n      // If this isn't a void Element, read its child nodes\n      if (!closed) {\n        if (localName == \"script\") {\n          this.readScript(node);\n        } else {\n          this.readChildren(node);\n        }\n        var closingTag = \"</\" + localName + \">\";\n        if (!this.match(closingTag)) {\n          this.error(\"expected '\" + closingTag + \"' and got \" + this.html.substr(this.currentChar, closingTag.length));\n          return null;\n        }\n      }\n\n      // Only use the first title, because SVG might have other\n      // title elements which we don't care about (medium.com\n      // does this, at least).\n      if (localName === \"title\" && !this.doc.title) {\n        this.doc.title = node.textContent.trim();\n      } else if (localName === \"head\") {\n        this.doc.head = node;\n      } else if (localName === \"body\") {\n        this.doc.body = node;\n      } else if (localName === \"html\") {\n        this.doc.documentElement = node;\n      }\n\n      return node;\n    },\n\n    /**\n     * Parses an HTML string and returns a JS implementation of the Document.\n     */\n    parse: function (html) {\n      this.html = html;\n      var doc = this.doc = new Document();\n      this.readChildren(doc);\n\n      // If this is an HTML document, remove root-level children except for the\n      // <html> node\n      if (doc.documentElement) {\n        for (var i = doc.childNodes.length; --i >= 0;) {\n          var child = doc.childNodes[i];\n          if (child !== doc.documentElement) {\n            doc.removeChild(child);\n          }\n        }\n      }\n\n      return doc;\n    }\n  };\n\n  // Attach the standard DOM types to the global scope\n  global.Node = Node;\n  global.Comment = Comment;\n  global.Document = Document;\n  global.Element = Element;\n  global.Text = Text;\n\n  // Attach JSDOMParser to the global scope\n  global.JSDOMParser = JSDOMParser;\n\n})(this);\n" +
`onmessage = function(data) { 
    var doc = new JSDOMParser().parse(data.data[0]); 
    var readability = new Readability(data.data[1], doc); 
    self.postMessage(readability.parse());
}`
